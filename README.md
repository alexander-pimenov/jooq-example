## Здесь изучаем JOOQ

### JOOQ и его кроличья нора. Как выжить без Hibernate
 - Ссылка на статью - https://habr.com/ru/articles/488522/
 - Ссылка на github на код из статьи - https://github.com/promoscow/jooq-example

В этой статье автор расскажет о JOOQ и его особенностях. 
Затронет следующие аспекты работы с JOOQ:

- Генерация сущностей.
- Написание запросов CRUD.
- Оптимизация запросов CRUD.
- Мапинг сущностей силами стандартной библиотеки JOOQ.
- Порассуждает о том, зачем всё это надо.

### JOOQ: Альтернатива JPA для Сложных Запросов и Высокой Производительности
 - Ссылка на видео - https://www.youtube.com/watch?v=TNLIfwxd02Q
 - Ссылка на github из видео - https://github.com/pavelitel05/jooq-demo-example

### QueryDSL: Предикаты
 - Ссылка на стаью - https://habr.com/ru/articles/344450/

> Предикаты позволяют работать с элементами базы данных как с обычными полями класса. При сборке gradle 
> создаёт специальные классы зависимостей, через которые и происходит поиск нужных записей в БД.

### Моё мнение:
- какой-то замкнутый круг: чтобы JOOQ сгенерировал код, нужно подключиться к БД с уже имеющимися таблицами,
а для этого нужно запустить миграцию liquibase. А liquibase проливает миграцию на БД, когда запускаю приложение, 
но не могу запустить приложение, т.к. не хватает для компиляции его уже сгенерированных жуком классов.
- поэтому делаю так: 
  - 1. запускаю docker-compose в котором уже есть скрипты для создания таблиц (без данных) в `postgres-compose/init-script`;
  - 2. запускаю генерацию классов JOOQ командой `./mvnw jooq-codegen:generate`, и теперь всё компилируется; 
  - 3. теперь классы сгенерированные JOOQ лежат в `src/main/java`, и я могу либо запускать приложение,
  - 4. либо запускать тесты и при этом будет отрабатывать миграция liquibase с пролитием данных (эти данные нужны нам для тестов)

---


